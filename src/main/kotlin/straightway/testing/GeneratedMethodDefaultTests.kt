/*
 * Copyright 2016 github.com/straightway
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package straightway.testing

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import straightway.error.Panic
import java.lang.reflect.Field
import java.lang.reflect.Modifier
import kotlin.reflect.KFunction
import kotlin.reflect.KParameter
import kotlin.reflect.full.declaredFunctions
import kotlin.reflect.jvm.isAccessible

fun Any.testAutoGeneratedDataClassMethods() {
    assertTrue(this::class.isData) { "${this::class} is no data class" }
    testCopy()
    testEquality()
    testToString()
}

private const val COMPONENT_PREFIX = "component"
private const val COMPONENT_PREFIX_LENGTH = COMPONENT_PREFIX.length

private val Any.copyMethodParameters: List<KParameter>
    get() = copyMethod.parameters.drop(1) // First param is 'this'

private val Any.copyMethod: KFunction<*>
    get() = this::class.declaredFunctions.single { it.name == "copy" }

private val Any.allFields: Array<Field>
    get() = this::javaClass.get()
            .declaredFields
            .filter { !it.name.startsWith("$") }
            .filter { !Modifier.isStatic(it.modifiers) }
            .toTypedArray()

private val Any.componentValues: List<Any?>
    get() = this::class.declaredFunctions
            .filter { it.name.matches(Regex("^$COMPONENT_PREFIX\\d+\$")) }
            .sortedBy { it.name.substring(COMPONENT_PREFIX_LENGTH).toInt() }
            .map { it.isAccessible = true; it.call(this) }

private fun Any.testEquality() {
    testEquals()
    testHashCode()
}

private fun Any.testToString() {
    assertEquals(toString(), copy(componentValues).toString())
}

private fun Any.testHashCode() {
    assertEquals(hashCode(), copy(componentValues).hashCode())
    forFieldNull { it.hashCode() }
}

private fun Any.testCopy() {
    assertEquals(this, copy(componentValues))
}

private fun Any.testEquals() {
    assertTrue(equals(copy(componentValues)))
    forFieldNull { assertFalse(equals(it)) }
    assertTrue(equals(this))
    assertFalse(equals(Any()))
}

private fun Any.forFieldNull(action: (Any) -> Unit) =
        allFields.forEach { action(getCopyWithFieldNullOrAltered(it)) }

private fun Any.getCopyWithFieldNullOrAltered(field: Field) =
        if (field.type.isPrimitive) getCopyWithPrimitiveFieldAltered(field)
        else getCopyWithFieldNull(field)

private fun Any.getCopyWithFieldNull(field: Field): Any {
    val instance = copy(componentValues)
    instance.setFieldValue(field, null)
    return instance
}

private fun Any.getCopyWithPrimitiveFieldAltered(field: Field): Any {
    val index = getIndexOfCopyParameter(field.name)
    val copyParams = getComponentValueNullOrAlteredAt(index)
    return copy(copyParams)
}

@Suppress("IMPLICIT_CAST_TO_ANY", "ComplexMethod")
private fun Any.getComponentValueNullOrAlteredAt(index: Int) =
        componentValues.getReplacedAt(
            index,
            componentValues[index].let {
                when (it) {
                    is Boolean -> !it
                    is Char -> it + 1
                    is Byte -> (it + 1).toByte()
                    is Short -> (it + 1).toShort()
                    is Int -> it + 1
                    is Long -> it + 1
                    is Float -> it + 1
                    is Double -> it + 1
                    else -> throw Panic("Unsupported primitive type: ${(it!!)::class}")
                }
            })

private fun <T> Iterable<T>.getReplacedAt(index: Int, replacement: T) =
        take(index) + replacement + drop(index + 1)

private fun Any.getIndexOfCopyParameter(field: String): Int {
    return copyMethodParameters.indexOfFirst { it.name == field }
}

private fun Any.copy(componentValues: List<Any?>): Any {
    val copyParamList = componentValues.toMutableList()
    copyParamList.add(0, this)
    return copyMethod.call(*copyParamList.toTypedArray())!!
}

private fun Any.setFieldValue(field: Field, value: Any?) {
    field.isAccessible = true
    field.set(this, value)
}